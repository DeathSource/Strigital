<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1.0, user-scalable=no" />
	<title>DigiViol</title>
	<style>
		:root { --bg:#000; --text:#cfd6e4; --accent:#ffd83b; --freeze:#6cc2ff; }

		html, body { height:100%; margin:0; background:var(--bg); color:var(--text); font-family:-apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; overscroll-behavior:none; }
		body { height:100dvh; -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; -webkit-tap-highlight-color:transparent; }

		.stage {
			position:relative; width:100vw; height:100dvh;
			padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
			box-sizing:border-box; display:flex; gap:0;
		}

		.pad { position:relative; height:100%; background:#000; box-shadow:inset 0 0 0 1px rgba(255,255,255,0.07); touch-action:none; overflow:hidden; }
		#padLeft { flex:2 1 0; }
		#padRight { flex:1 1 0; border-left:1px solid rgba(255,255,255,0.07); }

		.guides { position:absolute; inset:0; pointer-events:none; z-index:1; }
		.guide-line { position:absolute; left:0; right:0; }
		.guide-line.octave { height:2px; background:#fff; opacity:0.9; }
		.guide-line.fifth  { height:1.5px; background:var(--accent); opacity:0.95; }
		.guide-line.chrom  { height:1px; background:#fff; opacity:0.28; }

		.center-divider { position:absolute; top:0; bottom:0; left:50%; width:2px; background:#ffffff26; pointer-events:none; z-index:4; }

		.crosshair { position:absolute; pointer-events:none; z-index:3; opacity:0; transition:opacity 0.2s ease; }
		.crosshair.active { opacity:1; }
		.crosshair.frozen { opacity:1; }
		.crosshair .horizontal { position:absolute; height:2px; background:#ff4444; box-shadow:0 0 4px rgba(255,68,68,0.5); }
		.crosshair .vertical { position:absolute; width:2px; background:#ff4444; box-shadow:0 0 4px rgba(255,68,68,0.5); }
		.crosshair.frozen .horizontal, .crosshair.frozen .vertical { background:var(--freeze); box-shadow:0 0 4px rgba(108,194,255,0.5); }
		#crosshairA { left:0; width:50%; top:0; bottom:0; }
		#crosshairB { left:50%; width:50%; top:0; bottom:0; }

		.string-toggles { position:absolute; left:0; right:0; top:28px; display:flex; justify-content:space-between; gap:8px; padding:0 12px; z-index:3; }
		.string-toggles label { display:flex; align-items:center; gap:10px; color:#fff; font-size:16px; background:rgba(255,255,255,0.10); padding:8px 12px; border-radius:12px; }
		.string-toggles input { width:30px; height:30px; accent-color:#1f6feb; }

		.vol-meter { position:absolute; right:8px; bottom:8px; top:8px; width:10px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.15); border-radius:6px; overflow:hidden; }
		.vol-fill  { position:absolute; left:0; right:0; bottom:0; height:0%; background:linear-gradient(180deg, #8bd3ff, #3aa0ff); }
		#bowHud    { position:absolute; top:8px; left:50%; transform:translateX(-50%); font-variant-numeric:tabular-nums; font-size:16px; background:rgba(255,255,255,0.10); border:1px solid rgba(255,255,255,0.20); padding:4px 10px; border-radius:10px; pointer-events:none; opacity:0.95; }

		.trail-container { position:absolute; inset:0; pointer-events:none; z-index:2; }
		.trail-svg { position:absolute; inset:0; width:100%; height:100%; overflow:visible; }
		.trail-path { 
			fill:none; 
			stroke:rgba(255,216,59,0.8); 
			stroke-width:3; 
			stroke-linecap:round; 
			stroke-linejoin:round;
			filter:drop-shadow(0 0 6px rgba(255,216,59,0.4));
		}

		.unlock { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.7); backdrop-filter:blur(6px); z-index:9999; }
		.unlock.hidden { display:none; }
		.unlock .panel { color:#fff; text-align:center; max-width:min(90vw, 520px); padding:24px 18px; border:1px solid rgba(255,255,255,0.25); border-radius:16px; background:rgba(20,20,20,0.6); }
		.unlock .title { font-size:42px; font-weight:700; margin-bottom:6px; letter-spacing:0.5px; }
		.unlock .subtitle { font-size:16px; opacity:0.9; line-height:1.45; margin-bottom:14px; }
		.unlock .cta { display:inline-block; margin-top:8px; background:#1f6feb; color:#fff; padding:10px 14px; border-radius:12px; border:1px solid #ffffff66; cursor:pointer; touch-action:manipulation; }
		.unlock .cta:active { transform:translateY(1px); }
	</style>
</head>
<body>
	<div class="stage">
		<div class="pad" id="padLeft">
			<div class="guides" id="leftGuides"></div>
			<div class="center-divider"></div>

			<div class="crosshair" id="crosshairA">
				<div class="horizontal"></div>
				<div class="vertical"></div>
			</div>
			<div class="crosshair" id="crosshairB">
				<div class="horizontal"></div>
				<div class="vertical"></div>
			</div>

			<div class="string-toggles">
				<label><input type="checkbox" id="muteA" /> off A</label>
				<label><input type="checkbox" id="muteB" /> off B</label>
			</div>
		</div>

		<div class="pad" id="padRight">
			<div class="trail-container" id="trailContainer">
				<svg class="trail-svg" id="trailSvg" viewBox="0 0 100 100" preserveAspectRatio="none">
					<path class="trail-path" id="trailPath" d=""></path>
				</svg>
			</div>
			<div id="bowHud">0 0</div>
			<div class="vol-meter"><div class="vol-fill" id="volFill"></div></div>
			<div class="indicator" id="rightDot" style="left:50%; top:50%;"></div>
		</div>
	</div>

	<div class="unlock" id="unlock">
		<div class="panel">
			<div class="title">DigiViol</div>
			<div class="subtitle">A work in progress. Use the pad on the right for the bow control, and the two left pads for the strings. Click to enter.</div>
			<button class="cta" id="unlockBtn" type="button">Enter</button>
		</div>
	</div>
	<script>
		// Utils
		function clamp01(v){ return Math.min(1, Math.max(0, v)); }
		function getPadXY(pad, x, y){
			const r=pad.getBoundingClientRect();
			const px=(x-r.left)/r.width, py=(y-r.top)/r.height;
			return { x:clamp01(px), y:1-clamp01(py) };
		}
		function setRightDot(x, y){ rightDot.style.left=(x*100)+'%'; rightDot.style.top=((1-y)*100)+'%'; }
		function setCrosshair(s, x, y, active = true){ 
			const crosshair = s===0 ? crosshairA : crosshairB;
			const horizontal = crosshair.querySelector('.horizontal');
			const vertical = crosshair.querySelector('.vertical');
			
			if (active) {
				crosshair.classList.add('active');
				// Ensure y is valid to prevent jump to middle
				const safeY = clamp01(y);
				horizontal.style.top = ((1-safeY)*100) + '%';
				horizontal.style.left = '0';
				horizontal.style.right = '0';
				
				// Calculate local X with safety checks
				const safeX = clamp01(x);
				const localX = s===0 ? clamp01(safeX*2) : clamp01((safeX-0.5)*2);
				// Allow crosshair to reach edges for freeze detection
				const constrainedX = Math.max(0, Math.min(100, localX*100));
				vertical.style.left = constrainedX + '%';
				vertical.style.top = '0';
				vertical.style.bottom = '0';
			} else {
				crosshair.classList.remove('active');
			}
		}
		function setCrosshairFrozen(s, on){ (s===0?crosshairA:crosshairB).classList.toggle('frozen', !!on); }

		// DOM elements
		const leftPad = document.getElementById('padLeft');
		const rightPad = document.getElementById('padRight');
		const rightDot = document.getElementById('rightDot');
		const leftGuides = document.getElementById('leftGuides');
		const unlock = document.getElementById('unlock');
		const unlockBtn = document.getElementById('unlockBtn');
		const volFillEl = document.getElementById('volFill');
		const bowHud = document.getElementById('bowHud');
		const muteAEl = document.getElementById('muteA');
		const muteBEl = document.getElementById('muteB');
		const crosshairA = document.getElementById('crosshairA');
		const crosshairB = document.getElementById('crosshairB');

		function localXForString(px, s){ return s===0 ? clamp01(px/0.5) : clamp01((px-0.5)/0.5); }

		// Audio variables
		let audioCtx=null, unlockedAudio=false, audioStarted=false;
		let masterGain=null, currentHarm=0.5;

		function makeVoice(){
			return { placeholder: null };
		}
		const voiceA = makeVoice();
		const voiceB = makeVoice();

		// Pitch and states - REDUCED GRID RANGE
		const MIN_FREQ=165, OCTAVES=1.9, FIFTH=Math.pow(2,7/12);
		const START_FREQ_A = MIN_FREQ;
		const START_FREQ_B = MIN_FREQ*FIFTH;
		let freqA=START_FREQ_A, freqB=START_FREQ_B;

		let stringLocalX=[0.5,0.5];
		let stringActiveCount=[0,0];
		let frozen=[false,false];
		let stringMute=[false,false];
		let lastTapTime=[0,0];
		const DOUBLE_TAP_MS=280;

		let bowEngaged=false;
		let bowSpeedNorm = 0.0;
		let lastRightTime=null, lastRightY=0.5, rightActivePointer=null;

		// Decays
		const DECAY_HELD_S = 2.4;
		const DECAY_OPEN_S = 3.0;
		let decayingHeld=[false,false];
		let decayingOpen=[false,false];
		let decayTimerHeld=[null,null];
		let decayTimerOpen=[null,null];
		let decayStartVolume=[1.0,1.0];
		let decayStartTime=[0,0];

		let pitchLocked=[false,false];
		let pendingY=[0,0];

		// Volume map
		const VOL_LOG_C = 15;
		function mapSpeedToVolume(s){
			s = clamp01(s);
			if (s <= 0) return 0;
			return Math.log(1 + VOL_LOG_C*s) / Math.log(1 + VOL_LOG_C);
		}

		function ensureCtx(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }

		// Fluid Trail system
		const trailPoints = [];
		const MAX_TRAIL_POINTS = 30;
		const TRAIL_FADE_TIME = 1500;
		let trailPath = null;
		let trailSvg = null;

		function initTrail() {
			trailSvg = document.getElementById('trailSvg');
			trailPath = document.getElementById('trailPath');
		}

		function addTrailPoint(x, y) {
			const now = performance.now();
			const rightPadRect = rightPad.getBoundingClientRect();
			
			// Convert to SVG coordinates (percentage of container)
			const svgX = x * 100;
			const svgY = (1 - y) * 100;
			
			trailPoints.push({
				x: svgX,
				y: svgY,
				timestamp: now
			});

			// Remove old points
			while (trailPoints.length > MAX_TRAIL_POINTS) {
				trailPoints.shift();
			}
			
			updateTrailPath();
		}

		function updateTrailPath() {
			if (trailPoints.length < 2) {
				trailPath.setAttribute('d', '');
				return;
			}

			// Create smooth curve through points
			let pathData = `M ${trailPoints[0].x} ${trailPoints[0].y}`;
			
			for (let i = 1; i < trailPoints.length; i++) {
				const curr = trailPoints[i];
				const prev = trailPoints[i - 1];
				
				if (i === 1) {
					// First curve segment
					pathData += ` Q ${prev.x} ${prev.y} ${(prev.x + curr.x) / 2} ${(prev.y + curr.y) / 2}`;
				} else {
					// Smooth curve to next point
					pathData += ` T ${curr.x} ${curr.y}`;
				}
			}
			
			trailPath.setAttribute('d', pathData);
		}

		function updateTrail() {
			const now = performance.now();
			
			// Remove old points
			for (let i = trailPoints.length - 1; i >= 0; i--) {
				const point = trailPoints[i];
				const age = now - point.timestamp;
				
				if (age > TRAIL_FADE_TIME) {
					trailPoints.splice(i, 1);
				}
			}
			
			// Update opacity based on age
			if (trailPoints.length > 0) {
				const oldest = Math.max(...trailPoints.map(p => now - p.timestamp));
				const opacity = Math.max(0.2, 1 - (oldest / TRAIL_FADE_TIME));
				trailPath.style.opacity = opacity;
				updateTrailPath();
			} else {
				trailPath.setAttribute('d', '');
			}
			
			requestAnimationFrame(updateTrail);
		}

		function clearTrail() {
			trailPoints.length = 0;
			trailPath.setAttribute('d', '');
		}

		// GLITCH-FREE DUDUK AUDIO SYSTEM
		function initVoice(v, panValue, cfg){
			v.fundamental = audioCtx.createOscillator();
			v.fundamental.type = 'sine';
			v.fundamental.frequency.value = 440;
			
			v.harmonic2 = audioCtx.createOscillator();
			v.harmonic2.type = 'sine';
			v.harmonic2.frequency.value = 880;
			
			v.harmonic3 = audioCtx.createOscillator();
			v.harmonic3.type = 'sine';
			v.harmonic3.frequency.value = 1320;
			
			v.fundGain = audioCtx.createGain();
			v.harm2Gain = audioCtx.createGain();
			v.harm3Gain = audioCtx.createGain();
			
			v.gain = audioCtx.createGain();
			v.gain.gain.value = 0.0;
			v.pan = audioCtx.createStereoPanner();
			v.pan.pan.value = panValue;
			
			v.fundamental.connect(v.fundGain);
			v.harmonic2.connect(v.harm2Gain);
			v.harmonic3.connect(v.harm3Gain);
			
			[v.fundGain, v.harm2Gain, v.harm3Gain].forEach(g => g.connect(v.gain));
			v.gain.connect(v.pan).connect(masterGain);
			
			v.fundamental.start();
			v.harmonic2.start();
			v.harmonic3.start();
		}

		function setupAudio(){
			if(audioStarted) return;
			ensureCtx();

			masterGain = audioCtx.createGain(); 
			masterGain.gain.value = 0.7;
			masterGain.connect(audioCtx.destination);
			
			initVoice(voiceA, -0.2, {});
			initVoice(voiceB, +0.2, {});

			audioStarted = true;
		}

		function applyHarmonicsAndProfiles(x){
			currentHarm = clamp01(x);
			const t = audioCtx.currentTime;
			
			let fundLevel, harm2Level, harm3Level;
			if (currentHarm < 0.3) {
				fundLevel = 1.0;
				harm2Level = 0.45;
				harm3Level = 0.25;
			} else if (currentHarm < 0.7) {
				fundLevel = 0.85;
				harm2Level = 0.65;
				harm3Level = 0.35;
			} else {
				fundLevel = 0.7;
				harm2Level = 0.8;
				harm3Level = 0.5;
			}
			
			[voiceA, voiceB].forEach(voice => {
				voice.fundGain.gain.setTargetAtTime(fundLevel * 0.3, t, 0.02);
				voice.harm2Gain.gain.setTargetAtTime(harm2Level * 0.3, t, 0.02);
				voice.harm3Gain.gain.setTargetAtTime(harm3Level * 0.3, t, 0.02);
			});
		}

		function setStringFreqHz(i, f){
			if(i===0){ freqA=f; } 
			else { freqB=f; }
			
			const voice = i===0 ? voiceA : voiceB;
			const t = audioCtx.currentTime;
			
			voice.fundamental.frequency.setTargetAtTime(f, t, 0.01);
			voice.harmonic2.frequency.setTargetAtTime(f * 2, t, 0.01);
			voice.harmonic3.frequency.setTargetAtTime(f * 3, t, 0.01);
		}

		function setStringFrequency(i, y){
			const yClamped = clamp01(y);
			if (pitchLocked[i]) { pendingY[i]=yClamped; return; }
			const base = MIN_FREQ * Math.pow(2, OCTAVES * yClamped);
			const f = i===0 ? base : base * FIFTH;
			setStringFreqHz(i, f);
		}

		function setStringLocalVolume(i, lx){
			stringLocalX[i]=clamp01(lx);
			// Don't immediately set volume - only when bow is engaged
		}

		function isDecaying(i){ return decayingHeld[i] || decayingOpen[i]; }
		
		function getCurrentDecayVolume(i) {
			if (!isDecaying(i)) return 1.0;
			
			const now = audioCtx.currentTime;
			const elapsed = now - decayStartTime[i];
			const decayTime = decayingHeld[i] ? DECAY_HELD_S : DECAY_OPEN_S;
			
			if (elapsed >= decayTime) return 0.001;
			
			// Exponential decay formula: V(t) = V0 * e^(-t/Ï„)
			const progress = elapsed / decayTime;
			return decayStartVolume[i] * Math.pow(0.001, progress);
		}
		// Global decay volume (independent of string interactions)
		let globalDecayVolume = [0.0, 0.0]; // Current decay volume for each string
		let globalDecayActive = [false, false]; // Whether decay is active
		
		function refreshStringGate(i){
			const voice = i===0 ? voiceA : voiceB;
			
			let currentVol = 0.0;
			if (!stringMute[i]) {
				if (frozen[i]) {
					// Frozen strings: use crosshair X as volume multiplier
					currentVol = stringLocalX[i] * 0.5;
				} else if (globalDecayActive[i]) {
					// During decay: use global decay volume multiplied by crosshair X
					currentVol = globalDecayVolume[i] * stringLocalX[i] * 0.5;
				} else if (bowEngaged) {
					// Bow engaged: use crosshair X as volume
					currentVol = stringLocalX[i] * 0.5;
				}
				// No bow, no decay, no freeze = silence
			}
			
			voice.gain.gain.setTargetAtTime(currentVol, audioCtx.currentTime, 0.015);
		}
		function refreshAllGates(){ refreshStringGate(0); refreshStringGate(1); }

		function setActWhileBowing(vol){
			// Stop any active decay when bow engages
			globalDecayActive[0] = false;
			globalDecayActive[1] = false;
			
			// Refresh gates to use bow volume
			refreshAllGates();
		}
		
		function startGlobalDecay(stringIndex) {
			globalDecayActive[stringIndex] = true;
			globalDecayVolume[stringIndex] = 1.0; // Start at full volume
			
			// Animate decay over time
			const decayTime = 3000; // 3 seconds
			const startTime = performance.now();
			
			function updateDecay() {
				const elapsed = performance.now() - startTime;
				const progress = elapsed / decayTime;
				
				if (progress >= 1.0) {
					globalDecayActive[stringIndex] = false;
					globalDecayVolume[stringIndex] = 0.0;
				} else {
					// Exponential decay
					globalDecayVolume[stringIndex] = Math.pow(0.001, progress);
				}
				
				refreshStringGate(stringIndex);
				
				if (globalDecayActive[stringIndex]) {
					requestAnimationFrame(updateDecay);
				}
			}
			
			requestAnimationFrame(updateDecay);
		}

		function startHeldDecay(i){
			const voice = i===0 ? voiceA : voiceB;
			const t = audioCtx.currentTime;
			decayingHeld[i]=true;
			if (decayTimerHeld[i]) clearTimeout(decayTimerHeld[i]);
			
			// Record decay start parameters
			decayStartVolume[i] = Math.max(0.001, voice.gain.gain.value / 0.5); // Normalize back to 0-1
			decayStartTime[i] = t;
			
			voice.gain.gain.cancelScheduledValues(t);
			voice.gain.gain.setValueAtTime(Math.max(0.001, voice.gain.gain.value), t);
			voice.gain.gain.exponentialRampToValueAtTime(0.001, t + DECAY_HELD_S);
			
			decayTimerHeld[i] = setTimeout(()=>{ 
				decayingHeld[i]=false; 
				refreshStringGate(i); 
			}, DECAY_HELD_S*1000 + 50);
		}

		function startOpenDecay(i){
			const voice = i===0 ? voiceA : voiceB;
			const t = audioCtx.currentTime;
			decayingOpen[i]=true;
			if (decayTimerOpen[i]) clearTimeout(decayTimerOpen[i]);
			pitchLocked[i]=true;
			
			// Record decay start parameters
			decayStartVolume[i] = Math.max(0.001, voice.gain.gain.value / 0.5); // Normalize back to 0-1
			decayStartTime[i] = t;
			
			voice.gain.gain.cancelScheduledValues(t);
			voice.gain.gain.setValueAtTime(Math.max(0.001, voice.gain.gain.value), t);
			voice.gain.gain.exponentialRampToValueAtTime(0.001, t + DECAY_OPEN_S);
			
			decayTimerOpen[i] = setTimeout(()=>{ 
				decayingOpen[i]=false; 
				refreshStringGate(i); 
			}, DECAY_OPEN_S*1000 + 50);
		}

		function cancelDecay(i){
			const voice = i===0 ? voiceA : voiceB;
			const t = audioCtx.currentTime;
			decayingHeld[i]=false; decayingOpen[i]=false;
			if (decayTimerHeld[i]){ clearTimeout(decayTimerHeld[i]); decayTimerHeld[i]=null; }
			if (decayTimerOpen[i]){ clearTimeout(decayTimerOpen[i]); decayTimerOpen[i]=null; }
			
			voice.gain.gain.cancelScheduledValues(t);
			if (!bowEngaged) voice.gain.gain.setTargetAtTime(0.0, t, 0.01);
			refreshStringGate(i);
		}
		function cancelAllDecays(){ cancelDecay(0); cancelDecay(1); }

		// Unlock
		function maybeUnlock(){ 
			if(unlockedAudio) return; 
			ensureCtx(); 
			audioCtx.resume().then(()=>{ 
				setupAudio(); 
				unlockedAudio=true; 
				unlock.classList.add('hidden'); 
			}).catch(()=>{ 
				setupAudio(); 
				unlockedAudio=true; 
				unlock.classList.add('hidden'); 
			}); 
		}
		unlock.addEventListener('pointerdown', e=>{ e.preventDefault(); maybeUnlock(); }, {passive:false});
		unlockBtn.addEventListener('click', e=>{ e.preventDefault(); maybeUnlock(); });

		// Left pad interactions
		const leftPointerToString=new Map();
		leftPad.addEventListener('pointerdown',(e)=>{
			e.preventDefault(); maybeUnlock();
			const now=performance.now();
			const p=getPadXY(leftPad, e.clientX, e.clientY);
			const s = p.x < 0.5 ? 0 : 1;

			// Check for freeze/unfreeze at edges using local string coordinates
			const localX = localXForString(p.x, s);
			if (localX > 0.98) {
				// Right extremity - freeze
				frozen[s] = true;
				setCrosshairFrozen(s, true);
				setStringFrequency(s, p.y); 
				setStringLocalVolume(s, localX); 
				setCrosshair(s, p.x, p.y);
				refreshStringGate(s);
				return;
			} else if (localX < 0.02) {
				// Left extremity - unfreeze
				frozen[s] = false;
				setCrosshairFrozen(s, false);
				const crosshair = s===0 ? crosshairA : crosshairB;
				crosshair.classList.remove('active');
				refreshStringGate(s);
				return;
			}

			leftPad.setPointerCapture(e.pointerId);
			leftPointerToString.set(e.pointerId,s);
			
			// ALWAYS update pitch and crosshair - independent of volume/decay
			setStringFrequency(s,p.y); 
			setStringLocalVolume(s,localXForString(p.x, s));
			setCrosshair(s, p.x, p.y);
			stringActiveCount[s]++; 
			
			// Volume is handled independently by global decay or bow state
			refreshStringGate(s);
		},{passive:false});

		leftPad.addEventListener('pointermove',(e)=>{
			if(!leftPointerToString.has(e.pointerId)) return;
			const r = leftPad.getBoundingClientRect();
			if (e.clientX < r.left || e.clientX > r.right || e.clientY < r.top || e.clientY > r.bottom) return;

			e.preventDefault();
			const s=leftPointerToString.get(e.pointerId);
			const p=getPadXY(leftPad, e.clientX, e.clientY);
			
			// Check for freeze/unfreeze during move too
			const localX = localXForString(p.x, s);
			if (localX > 0.98 && !frozen[s]) {
				// Right extremity - freeze during move
				frozen[s] = true;
				setCrosshairFrozen(s, true);
			} else if (localX < 0.02 && frozen[s]) {
				// Left extremity - unfreeze during move
				frozen[s] = false;
				setCrosshairFrozen(s, false);
			}
			
			// Update frequency and volume regardless of freeze state
			setStringFrequency(s,p.y);
			setStringLocalVolume(s,localXForString(p.x, s));
			setCrosshair(s, p.x, p.y);
			
			// If frozen, ensure it keeps playing at the crosshair level
			if (frozen[s]) {
				refreshStringGate(s);
			}
		},{passive:false});

		leftPad.addEventListener('pointerup',(e)=>{
			if(!leftPointerToString.has(e.pointerId)) return;
			e.preventDefault();
			const s=leftPointerToString.get(e.pointerId);
			leftPointerToString.delete(e.pointerId);
			stringActiveCount[s]=Math.max(0,stringActiveCount[s]-1);

			pitchLocked[s]=false; pendingY[s]=0;
			
			// When crosshair is removed, string becomes 'open' (pitch = 0 as you described)
			if (!frozen[s]) {
				setStringFreqHz(s, s===0?START_FREQ_A:START_FREQ_B);
				const crosshair = s===0 ? crosshairA : crosshairB;
				crosshair.classList.remove('active');
			}

			refreshStringGate(s);
		},{passive:false});

		leftPad.addEventListener('pointercancel',(e)=>{
			if(!leftPointerToString.has(e.pointerId)) return;
			const s=leftPointerToString.get(e.pointerId);
			leftPointerToString.delete(e.pointerId);
			stringActiveCount[s]=Math.max(0,stringActiveCount[s]-1);

			pitchLocked[s]=false; pendingY[s]=0;
			setStringFreqHz(s, s===0?START_FREQ_A:START_FREQ_B);
			if (!frozen[s]) setCrosshair(s, 0, 0, false);

			refreshStringGate(s);
		},{passive:false});

		// Mutes
		function updateMute(i, val){ stringMute[i]=val; refreshStringGate(i); }
		muteAEl.addEventListener('change', e=>updateMute(0, e.target.checked));
		muteBEl.addEventListener('change', e=>updateMute(1, e.target.checked));

		// Right pad interactions
		rightPad.addEventListener('pointerdown',(e)=>{
			e.preventDefault(); maybeUnlock();
			rightPad.setPointerCapture(e.pointerId); rightActivePointer=e.pointerId;
			const p=getPadXY(rightPad, e.clientX, e.clientY);
			setRightDot(p.x,p.y);
			addTrailPoint(p.x, p.y);
			lastRightTime=performance.now(); lastRightY=p.y;

			cancelAllDecays();
			for(let i=0;i<2;i++){ 
				if (pitchLocked[i]){ 
					pitchLocked[i]=false; 
					setStringFrequency(i, pendingY[i] ?? 0); 
					if (pendingY[i] > 0) setCrosshair(i, 0.5, pendingY[i]);
				}
			}

			if (stringActiveCount[0]===0 && !frozen[0]) {
				setStringFreqHz(0, START_FREQ_A);
				setCrosshair(0, 0, 0, false);
			}
			if (stringActiveCount[1]===0 && !frozen[1]) {
				setStringFreqHz(1, START_FREQ_B);
				setCrosshair(1, 0, 0, false);
			}

			bowEngaged=true; refreshAllGates();
			applyHarmonicsAndProfiles(p.x);
			setActWhileBowing(mapSpeedToVolume(0));
			updateBowOutputs();
		},{passive:false});

		rightPad.addEventListener('pointermove',(e)=>{
			if(rightActivePointer!==e.pointerId) return;
			e.preventDefault();
			const p=getPadXY(rightPad, e.clientX, e.clientY);
			setRightDot(p.x,p.y);
			addTrailPoint(p.x, p.y);
			const now=performance.now();
			const dt=Math.max(0.001,(now-lastRightTime)/1000);
			const dy=p.y-lastRightY;
			const instPerSec=Math.abs(dy)/dt;
			bowSpeedNorm = clamp01(instPerSec / (1.0/0.5));
			lastRightTime=now; lastRightY=p.y;

			setActWhileBowing(mapSpeedToVolume(bowSpeedNorm));
			applyHarmonicsAndProfiles(p.x);
			updateBowOutputs();
		},{passive:false});

		rightPad.addEventListener('pointerup',(e)=>{
			if(rightActivePointer!==e.pointerId) return;
			e.preventDefault();

			const openA = !stringMute[0] && stringActiveCount[0]===0 && !frozen[0];
			const openB = !stringMute[1] && stringActiveCount[1]===0 && !frozen[1];

			rightActivePointer=null; bowEngaged=false; 
			clearTrail();

			// Start global decay for any active strings
			if (!stringMute[0] && (stringActiveCount[0] > 0 || openA)) {
				startGlobalDecay(0);
			}
			if (!stringMute[1] && (stringActiveCount[1] > 0 || openB)) {
				startGlobalDecay(1);
			}
			
			refreshAllGates();

			updateBowOutputs();
		},{passive:false});

		rightPad.addEventListener('pointercancel',(e)=>{
			if(rightActivePointer!==e.pointerId) return;

			const openA = !stringMute[0] && stringActiveCount[0]===0 && !frozen[0];
			const openB = !stringMute[1] && stringActiveCount[1]===0 && !frozen[1];

			rightActivePointer=null; bowEngaged=false; 
			clearTrail();

			// Start global decay for any active strings
			if (!stringMute[0] && (stringActiveCount[0] > 0 || openA)) {
				startGlobalDecay(0);
			}
			if (!stringMute[1] && (stringActiveCount[1] > 0 || openB)) {
				startGlobalDecay(1);
			}
			
			refreshAllGates();

			updateBowOutputs();
		},{passive:false});

		// Idle monitoring and final setup
		function monitorIdle(){
			if (rightActivePointer!=null && bowEngaged){
				const idleMs = performance.now() - (lastRightTime ?? 0);
				if (idleMs > 80 && bowSpeedNorm > 0){
					bowSpeedNorm = 0.0;
					setActWhileBowing(0.0);
					updateBowOutputs();
				}
			}
			requestAnimationFrame(monitorIdle);
		}
		requestAnimationFrame(monitorIdle);

		function updateBowOutputs(){
			const vol = mapSpeedToVolume(bowSpeedNorm);
			volFillEl.style.height = `${Math.round((bowEngaged?vol:0)*100)}%`;
			bowHud.textContent = `${Math.round(bowSpeedNorm*100)} ${Math.round(vol*100)}`;
		}

		function buildGuides(){
			leftGuides.innerHTML='';
			const steps=Math.round(OCTAVES*12);
			for(let k=0;k<=steps;k++){
				const y=k/steps;
				const div=document.createElement('div');
				const isOct=(k%12===0), isFifth=(k%12===7);
				div.className='guide-line '+(isOct?'octave':(isFifth?'fifth':'chrom'));
				div.style.top=((1-y)*100)+'%';
				leftGuides.appendChild(div);
			}
		}
		function boot(){
			buildGuides();
			initTrail();
			requestAnimationFrame(updateTrail);
		}
		window.addEventListener('load', boot);

		document.addEventListener('gesturestart', e=>e.preventDefault());
		document.addEventListener('gesturechange', e=>e.preventDefault());
		document.addEventListener('gestureend', e=>e.preventDefault());
	</script>
</body>
</html>
